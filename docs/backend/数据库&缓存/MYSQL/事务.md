### 知乎解释

- https://www.zhihu.com/question/392569386/answer/1434210648
- https://www.zhihu.com/question/363706687/answer/3344602976

“脏读”指读到了未提交的数据，然后基于这个数据做了一些事情，结果做完发现数据被回滚了。可以理解为领导还没下达正式任务你就凭着自己的揣摩开始干活，结果活干完了，任务的内容被改了。

“不可重复读”好一点，读到的是已提交的数据，比如某个读事务持续时间比较长，期间多次读取某个元组，每次读到的都是被别人改过并已提交的不同数据。可以理解为在执行任务的过程中，领导的指令一直在变。。但好歹是正式下达的指令。

“幻读”是指读的过程中，某些元组被增加或删除，这样进行一些集合操作，比如算总数，平均值等等，就会每次算出不一样的数。

所以“不可重复读”和“幻读”都是读的过程中数据前后不一致，只是前者侧重于修改，后者侧重于增删。个人认为，严格来讲“幻读”可以被称为“不可重复读”的一种特殊情况，没错的。但是从数据库管理的角度来看二者是有区别的。解决“不可重复读”只要加行级锁就可以了。而解决“幻读”则需要加表级锁，或者采用其他更复杂的技术，总之代价要大许多。这是搞数据库的那帮家伙非要把这两者区分开的动机吧。

禁止写时读，避免了“脏读”，对应隔离级别read committed。

禁止读时写，避免了“不可重复读”，对应隔离级别repeatable read。

而为了避免“幻读”，干脆把整个表给锁住了，只能是serialize了。

隔离级别越高，并行度越低，付出的代价越大。

顺便说一下，phantom这个词是幻影，幽灵的意思，跟“幻读”的现象没有直接关系。很多文章说遇到“幻读”就像出现幻觉一样，个人以为十分牵强。“幻读”就是软件工程中一个很普通的问题，是人类思虑不周全的结果。老外工程师通过禁止读的时候修改解决了“不可重复读”的问题，本以为万事大吉了，谁知又出现了增加导致的不一致，不由感慨：我X真是个phantom。用中国话说，就是真TM见鬼了。国内翻译成了“幻读”，搞得很神秘，逼格很高的样子。

### 基本解释
1. 脏读：
 ◦ 含义：一个事务读取到了另一个未提交事务写入的数据。
 ◦ 举例：事务 A 修改了一条数据但未提交，此时事务 B 读取了这条被事务 A 修改过的数据。如果事务 A 最终回滚，那么事务 B 读取到的数据就是 “脏” 数据，因为这个数据从未真正在数据库中存在过。
 2. 不可重复读：
 ◦ 含义：在一个事务中，多次读取同一数据集合，但是在这个过程中，另一个事务对该数据集合进行了修改，导致这个事务多次读取的数据不一致。
 ◦ 举例：事务 A 读取一条数据，此时事务 B 修改了这条数据并提交。接着事务 A 再次读取这条数据时，发现数据与第一次读取的不一样。
 3. 幻读：
 ◦ 含义：一个事务在两次查询中得到的结果集不同，是由于另一个事务插入或删除了数据，使得第一个事务在第二次查询时出现了新的数据行或丢失了一些数据行。
 ◦ 举例：事务 A 按照某个条件查询数据，得到结果集。此时事务 B 插入了一些满足事务 A 查询条件的数据行并提交。当事务 A 再次按照相同条件查询时，发现结果集中多了一些数据行，就像出现了 “幻觉” 一样。
 
二、四种事务隔离级别解释
 1. 读未提交（Read uncommitted）：
 ◦ 允许脏读、不可重复读和幻读。
 ◦ 在这个隔离级别下，事务可以读取到其他未提交事务写入的数据，数据的一致性和完整性得不到保证。虽然这种隔离级别可以提高并发性能，但由于存在脏读等问题，实际应用中很少使用。
 2. 读已提交（Read committed）：
 ◦ 避免脏读，但允许不可重复读和幻读。
 ◦ 在这个隔离级别下，事务只能读取到其他事务已经提交的数据。这样就避免了脏读问题，但仍然可能出现不可重复读和幻读。大多数数据库系统的默认隔离级别是读已提交。
 3. 可重复读（Repeatable read）：
 ◦ 避免脏读和不可重复读，但可能出现幻读。
 ◦ 在这个隔离级别下，事务在执行期间多次读取同一数据集合时，会看到相同的数据，即避免了不可重复读问题。但是，可能会出现幻读，因为其他事务可以在该事务执行期间插入新的数据行。
 4. 串行化（Serializable）：
 ◦ 避免脏读、不可重复读和幻读。
 ◦ 在这个隔离级别下，事务会按照顺序依次执行，就像一个事务一个事务地串行执行一样。这种隔离级别可以保证数据的一致性和完整性，但会极大地降低并发性能，只有在对数据一致性要求非常高的情况下才会使用。