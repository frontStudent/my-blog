## 缓存击穿
定义：缓存击穿是指一个热点 key（访问非常频繁的 key），在它过期的瞬间，大量的请求同时访问这个过期的 key，这些请求会直接打到数据库，就像在缓存层被 “击穿” 了一个洞一样。
场景示例：假设某热门商品在电商平台做限时秒杀活动，这个商品的信息（如价格、库存等）被缓存在 Redis 中。当缓存中的商品信息过期时，正好大量用户同时点击查看该商品详情，这些请求发现缓存中没有数据，就会直接查询数据库。
危害：大量请求直接访问数据库，可能会导致数据库压力骤增，甚至使数据库服务崩溃。如果数据库性能下降，会影响整个系统的响应速度，导致用户体验变差，例如用户长时间无法加载商品详情页面。

### 解决方案
1. 设置热点key永不过期
2. 针对热点key采用分布式锁，当大量查询同一个key的请求时，只能有一个请求获取到锁，查询数据库，然后将结果放入到缓存中，然后释放锁，此时，其他处于锁等待的请求即可继续执行，由于此时缓存中已经有了数据，所以直接从缓存中获取到数据返回，并不会查询数据库。

## 缓存雪崩
定义：缓存雪崩是指在某一时刻，缓存中的大量数据同时过期（或者缓存服务器出现故障），导致大量的请求直接访问数据库，就像雪山崩塌一样，对数据库造成巨大的压力。
场景示例：比如在一个新闻资讯网站，缓存了许多新闻文章的内容。如果这些缓存的新闻内容设置了相同的过期时间，当这些缓存同时过期时，大量用户访问新闻页面的请求就会涌向数据库。另外，假如缓存服务器所在的机房出现网络故障或硬件故障，也会导致缓存雪崩的情况。
危害：它对数据库的冲击比缓存击穿更严重，因为涉及的数据量更多。可能会导致数据库服务器过载，甚至使数据库连接池耗尽，进而使整个系统无法正常提供服务。例如，用户无法正常访问新闻内容，网站出现大量的 404 错误或加载缓慢的情况。

### 解决方案
1. 分散过期时间：为了避免缓存雪崩，可以将缓存的过期时间分散开，比如在原有的过期时间基础上增加一个随机值，使得缓存的过期时间分布均匀，避免同时过期。
2. 高可用缓存架构：使用高可用的缓存架构，比如使用 Redis 集群，即使部分缓存节点失效，其他节点仍然可以提供服务，保证缓存的可用性。

## 缓存穿透
定义：缓存穿透是指查询一个根本不存在的数据，这个数据既不在缓存中，也不在数据库中。由于缓存和数据库都没有这个数据，所以每次请求都会穿透缓存直接访问数据库，造成数据库压力增大。
场景示例：假设有人恶意使用一些不存在的用户 ID 频繁访问用户信息接口。比如，用户 ID 是从 1 开始递增的整数，攻击者使用负数或极大的整数作为用户 ID 进行查询，这些 ID 对应的用户信息在缓存和数据库中都不存在，每次请求都会直接查询数据库。
危害：这种情况会导致数据库浪费大量的资源去处理这些无效的请求。如果攻击流量足够大，会使数据库性能下降，甚至影响正常的业务请求处理，导致系统响应变慢，增加服务器的负载。

### 解决方案
1. 缓存空值：当查询一个不存在的数据时，缓存一个空对象，并设置一个较短的过期时间（比如几分钟），这样下次同样的请求就可以直接从缓存中获取结果，而不会继续查询数据库。
2. 布隆过滤器

布隆过滤器是一种空间效率极高的概率型数据结构，它由一个bit数组和多个哈希函数组成。当一个元素被加入布隆过滤器时，通过多个哈希函数计算出该元素对应的多个位置，然后将位数组中这些位置的值设为1。

假设有一个布隆过滤器，位数组长度为 ，有 3 个哈希函数 h1、h2、h3。当要插入元素 “apple” 时，h1(“apple”) = 2，h2(“apple”) = 3，h3(“apple”) = 6，那么就将位数组中下标为 2、3、6 的位置设为 1。

布隆过滤器判断一个元素是否存在时，同样使用这些哈希函数计算该元素对应的位置。如果这些位置的值全部为 1，那么这个元素很可能存在；如果其中有一个位置的值为 0，那么这个元素一定不存在。

为什么说很可能存在，因为由于哈希冲突，布隆过滤器可能会出现误判。即一个元素实际上不存在，但是经过哈希函数计算后，对应的位置全部为 1，导致布隆过滤器判断这个元素存在。不过可以通过合理设置布隆过滤器的参数（如位数组大小和哈希函数个数）来降低误判率。
位数组越大、哈希函数个数越多，误判率越低，但同时也会增加空间和计算成本。

布隆过滤器的一个关键限制是它不支持删除操作。这是因为，一旦一个位被设置为1，就无法确定它是被哪个元素设置的。因此，简单的清除一个位可能会破坏其他元素的存在性记录。如果需要删除功能，可以采用以下几种策略：

计数布隆过滤器：使用计数布隆过滤器（Counting Bloom Filter），它可以存储每个位的计数值，从而允许减小计数以模拟删除。但是这种方法会增加内存消耗。
可删除布隆过滤器：一些变种的布隆过滤器，如 Scalable Bloom Filters 或者 Bloomier Filters，提供了更复杂的机制来支持删除操作，但同样可能增加内存使用和复杂性。
结合其他数据结构：另一种方法是结合使用布隆过滤器和其他数据结构（如哈希表），用布隆过滤器来快速排除不存在的元素，而用哈希表来存储实际的数据和处理删除操作。
