## 2024-1-9更新：封装了一个可拖拽可形变可编辑的vue组件发布为npm包 
后续可能有新的迭代，在下面的地址中查看源码和readme文档，不在本文中继续更新
npm包地址：https://www.npmjs.com/package/vue-magic-box
github仓库地址：https://github.com/frontStudent/vue-magic-box.git

================= 以下为原内容 =================

通过拖拽来控制元素的大小和位置是很经典的前端需求，比如照片上传时的截图框等

### “八点法”拖拽拉伸
一般会需要实现以下两个功能：
1. 在一个div的四个角和四个边的中点绘出八个指示点，当鼠标移至指示点时，光标变为对应的箭头，然后点击拉伸时可以实现目标元素在对应方向上的变化
2. 当鼠标移至目标元素中间时，光标变为拖动符号，然后点击拖动时可以实现目标元素位置的变化

#### 实现
不管是原生js还是声明式框架实现，核心都在于监听浏览器事件mousemove/mousedown/mouseup，适当修改对应元素的width/height/left/top/cursor等css属性，以达到拖拽拉伸和光标变化的效果。

- 参考链接1 https://www.zhihu.com/question/449608492
看这个问题下的一个回答，没有使用框架，就是原生的html+css+js去实现的。

- 参考链接2 https://github.com/a7650/vue3-draggable-resizable
这是一个基于vue3造的轮子，参考其readme文档即可

### 只要在边界都可拖拽拉伸
适当修改功能需求的第一点，当鼠标移到div边界的任意一个位置时，光标都会变为对应的箭头，然后点击拉伸时可以实现目标元素在对应方向上的变化。

我们将以上的dom操作逻辑封装为了一个vue3自定义指令v-resize

```js title="vResize.js"
// vResize.js
export const vResize = {
  mounted: (el, binding) => {
    let startX, startY, startWidth, startHeight, startLeft, startTop, moving = false
    el.style.maxWidth = binding.value?.maxWidth || '200px'
    el.style.maxHeight = binding.value?.maxHeight || '300px'

    const onMouseDown = (e) => {
      startX = e.clientX
      startY = e.clientY
      startWidth = el.offsetWidth
      startHeight = el.offsetHeight
      startLeft = el.offsetLeft
      startTop = el.offsetTop
      document.addEventListener('mousemove', onStartResize)
      document.addEventListener('mouseup', onMouseUp)
    }

    // 鼠标按下开始拖动
    const onStartResize = (e) => {
      moving = true
      console.log(el.style.cursor)
      const dx = e.clientX - startX
      const dy = e.clientY - startY
      let width = startWidth,
        height = startHeight,
        left = startLeft,
        top = startTop
      const direction = el.style.cursor?.split('-')?.[0]
      // 拖拽移动位置
      if (direction === 'move') {
        el.style.left = startLeft + dx + 'px'
        el.style.top = startTop + dy + 'px'
        return
      }
      // 水平方向
      if (direction.includes('e')) {
        width = startWidth + dx + 'px'
        left = startLeft + dx / 2 + 'px'
      }
      if (direction.includes('w')) {
        width = startWidth - dx + 'px'
        left = startLeft + dx / 2 + 'px'
      }
      // 垂直方向
      if (direction.includes('s')) {
        height = startHeight + dy + 'px'
        top = startTop + dy / 2 + 'px'
      }
      if (direction.includes('n')) {
        height = startHeight - dy + 'px'
        top = startTop + dy / 2 + 'px'
      }
      el.style.width = width
      el.style.height = height
      el.style.left = left
      el.style.top = top
    }

    // cursor样式根据边界位置变化
    // e.offsetX / e.offsetY 是鼠标在元素内部的坐标，是相对于元素边界的
    // el.offsetWidth / el.offsetHeight 是元素的大小
    const onTouchBoundary = (e) => {
      if(moving) return
      let limit = 10
      // 是否在左上角
      if (e.offsetX < limit && e.offsetY < limit) {
        el.style.cursor = 'nw-resize'
        return
      }
      // 是否在右下角
      if (
        e.offsetX > el.offsetWidth - limit &&
        e.offsetY > el.offsetHeight - limit
      ) {
        el.style.cursor = 'se-resize'
        return
      }
      // 是否在左下角
      if (e.offsetX < limit && e.offsetY > el.offsetHeight - limit) {
        el.style.cursor = 'sw-resize'
        return
      }
      // 是否在右上角
      if (e.offsetX > el.offsetWidth - limit && e.offsetY < limit) {
        el.style.cursor = 'ne-resize'
        return
      }
      // 是否在左边界
      if (e.offsetX < limit) {
        el.style.cursor = 'w-resize'
        return
      }
      // 是否在右边界
      if (e.offsetX > el.offsetWidth - limit) {
        el.style.cursor = 'e-resize'
        return
      }
      // 是否在上边界
      if (e.offsetY < limit) {
        el.style.cursor = 'n-resize'
        return
      }
      // 是否在下边界
      if (e.offsetY > el.offsetHeight - limit) {
        el.style.cursor = 's-resize'
        return
      }
      el.style.cursor = 'move'
    }

    const onMouseUp = () => {
      moving = false
      document.removeEventListener('mousemove', onStartResize)
      document.removeEventListener('mouseup', onMouseUp)
    }

    el.addEventListener('mousemove', onTouchBoundary)
    el.addEventListener('mousedown', onMouseDown)
  }
}
```

在其他组件中使用该指令：

```html
<template>
  <div class="form-container" v-resize>
  </div>
</template>

<script setup>
import { vResize } from './directives/VResize.js'
</script>

<style scoped>
.form-container {
  position: absolute;
  left: 50%;
  top: 50%;
  /* transform必加 */
  transform: translate(-50%, -50%); 
  width: 200px;
  height: 200px;
  border: 1px solid #ccc;
}
</style>
```